[
  {
    "objectID": "course-notes.html",
    "href": "course-notes.html",
    "title": "Course Notes",
    "section": "",
    "text": "This section contains the notes from the course.",
    "crumbs": [
      "Course Notes"
    ]
  },
  {
    "objectID": "assignments.html",
    "href": "assignments.html",
    "title": "Assignments",
    "section": "",
    "text": "This section contains the assignments from the course.",
    "crumbs": [
      "Assignments"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Computational Methods in R",
    "section": "",
    "text": "Overview\n&lt; insert table with links to each chapters and brief descriptions from the schedule &gt;\n\n\n\n\n\n\nQuarto blog publish details\n\n\n\nThis book was created using Quarto and published with Github Pages.\n\n\n\n\n\n\n\n\nGithub repository for code\n\n\n\nYou can find the code to reproduce this project at coltongearhart/climate-dataviz.",
    "crumbs": [
      "Overview"
    ]
  },
  {
    "objectID": "beyond-dataframes.html#overview",
    "href": "beyond-dataframes.html#overview",
    "title": "1  Beyond Dataframes",
    "section": "\n1.1 Overview",
    "text": "1.1 Overview\nIn this mini courese we will be exploring the use of computing and non-parametric method in statistical practice. This will look like a set of general programming and computing topics and methods. This will require that we use a statistical programming language in sophisticated ways, and the module will specifically explore techniques for advanced programming in R.\nReadings come from the Advanced R textbook by Hadley Wickham.\n\n``To understand computations in R, two slogans are helpful: Everything that exists is an object. Everything that happens is a function call.’’ — John Chambers\n\nYou already know the basics from your previous coursework. Here we will briefly discuss the following:\n\n\nDocumenting Code\n\nNaming objects, functions, variables\nDescriptive comments\nStructural organization\n\n\n\nObjects\n\nVectors, atomic types, attributes\nDataframes\nMatrices\n\n\n\nFunctions\n\nUsing existing functions\nFinding and reading help documentation",
    "crumbs": [
      "Course Notes",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Beyond Dataframes</span>"
    ]
  },
  {
    "objectID": "beyond-dataframes.html#coding-in-r---documenting-with-quarto",
    "href": "beyond-dataframes.html#coding-in-r---documenting-with-quarto",
    "title": "1  Beyond Dataframes",
    "section": "\n1.2 Coding in R - Documenting with Quarto",
    "text": "1.2 Coding in R - Documenting with Quarto\nIn this mini-course, we will be coding and programming using the R language. We will be leveraging the benefits of the open source structure of R by using some of the excellent software packages developed by members of the R community. We will also be exploring the efficient data structures and functions available in Base R. We will be interacting with the R language using the R Studio Interactive Development Environment (IDE).\nWe will be using Quarto to document our work because it is capable of integrating the process of writing in both programming and natural languages. It is great to be able to transition back and forth between paragraphs expressing what we are trying to accomplish statistically to the computational evidence to support our results. Each course notes will be put together as a Quarto document.\nSupplementary Resources for R Markdown:\n\nQuarto Website\nQuarto computations in R\nR Markdown Reference Guide",
    "crumbs": [
      "Course Notes",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Beyond Dataframes</span>"
    ]
  },
  {
    "objectID": "beyond-dataframes.html#r-basics",
    "href": "beyond-dataframes.html#r-basics",
    "title": "1  Beyond Dataframes",
    "section": "\n1.3 R Basics",
    "text": "1.3 R Basics\nData structures\n\nVectors are the atomic vectors of type: numeric, character, logical\nEssentially every data structure we use is one of these vectors, but with additional attributes or several vectors added together.\nA fundamental aspect of good computing is understanding how R saves the information.\nWe can also concatenate vectors of different types. However, atomic vectors cannot contain more than one type of data, so it coerces values into a easier way.\nWe are starting to think about these vector / dataframes. A vector is a one dimensional, matrix is two dimensions, arrays are three dimensional.\n\nExample below for demonstrating different aspects of R such as packages, objects, functions, etc. and for improving code readability.\n\nThe assignment arrow is pronounced “gets”, so the name gets the thing on the right.\n\n\n# poor formatting makes cord hard to read \nlibrary(tidyverse)\nrealestate&lt;-read.csv(\"Files/Data/realestate.csv\")\nprice_means&lt;-rep(NA   ,1000);price_medians&lt;-rep(NA   ,1000)\nfor(b in 1:1000){`bootstrap sample`&lt;-sample_n(realestate  ,nrow(realestate)  ,T)\nprice_means[b]&lt;-mean(`bootstrap sample`$price   )\nprice_medians[b]&lt;-median(`bootstrap sample`$price    )}\nquantile(price_means   ,c(0.025,0.975));quantile(price_medians   ,c(0.025,0.975));t.test(realestate$price)\n\nReformat R scripts\n\n\nUse the following shortcuts in RStudio to reformat your code in the qmd file:\n\nCmd + I: Fixes line indentations.\nCmd + Shift + A: Does a complete reformat of the selected part of a code.\n\n\n\n\n# use keyboard shortcut for quick fixes\nlibrary(tidyverse)\nrealestate &lt;- read.csv(\"Files/Data/realestate.csv\"); price_means &lt;- rep(NA   , 1000)\nprice_medians &lt;- rep(NA   , 1000)\nfor (b in 1:1000) {\n  `bootstrap sample` &lt;- sample_n(realestate  , nrow(realestate)  , T)\n  price_means[b] &lt;- mean(`bootstrap sample`$price)\n  price_medians[b] &lt;- median(`bootstrap sample`$price)\n}\nquantile(price_means   , c(0.025, 0.975))\nquantile(price_medians   , c(0.025, 0.975))\nt.test(realestate$price)\n\nUse automated code parsing and then copy result into qmd file.\n\nUse knitr chunk options with formatR installed: tidy: formatR. This parses the code with tidy_source() behind the scenes.\nCan specify additional options with #| tidy-opts: #|   -. View available ones in the help documentation ?tidy_source or this r markdown cookbook section.\n\n\n# automated code parsing -&gt; this has the same source as the first ugly code,\n# but echos nicely\nlibrary(tidyverse)\nrealestate &lt;- read.csv(\"Files/Data/realestate.csv\")\nprice_means &lt;- rep(NA, 1000)\nprice_medians &lt;- rep(NA, 1000)\nfor (b in 1:1000) {\n    `bootstrap sample` &lt;- sample_n(realestate, nrow(realestate), T)\n    price_means[b] &lt;- mean(`bootstrap sample`$price)\n    price_medians[b] &lt;- median(`bootstrap sample`$price)\n}\nquantile(price_means, c(0.025, 0.975))\nquantile(price_medians, c(0.025, 0.975))\nt.test(realestate$price)\n\nRebuilding code for readability (with comments)\n\n# now we can add comments and space out the code for better readability\nlibrary(tidyverse)\nrealestate &lt;- read.csv(\"Files/Data/realestate.csv\")\n\n# initializing the storage space for the bootstrap means and medians\nprice_means &lt;- rep(NA, 1000)\nprice_medians &lt;- rep(NA, 1000)\n\n# loop over 1000 repeated bootstrap samples, saving the means and medians\nfor (b in 1:1000) {\n  bootstrap_sample &lt;- sample_n(realestate, nrow(realestate), T)\n  price_means[b] &lt;- mean(bootstrap_sample$price)\n  price_medians[b] &lt;- median(bootstrap_sample$price)\n}\n\n# calculate the quantiles of the collected means and medians\nquantile(price_means, c(0.025, 0.975))\n\n    2.5%    97.5% \n266524.1 289583.4 \n\nquantile(price_medians, c(0.025, 0.975))\n\n  2.5%  97.5% \n219900 239950 \n\n# do these intervals match will with confidence intervals using central limit theorem?\n# -&gt; compare interval to t-interval\nt.test(realestate$price)\n\n\n    One Sample t-test\n\ndata:  realestate$price\nt = 46.034, df = 521, p-value &lt; 2.2e-16\nalternative hypothesis: true mean is not equal to 0\n95 percent confidence interval:\n 266034.8 289753.5\nsample estimates:\nmean of x \n 277894.1",
    "crumbs": [
      "Course Notes",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Beyond Dataframes</span>"
    ]
  },
  {
    "objectID": "beyond-dataframes.html#advanced-programming",
    "href": "beyond-dataframes.html#advanced-programming",
    "title": "1  Beyond Dataframes",
    "section": "\n1.4 Advanced Programming",
    "text": "1.4 Advanced Programming\n\n``We are adventurers! We do not play on the playgrounds. We roam in the jungles!’’ — Jie Li (Dr. Maurer’s Grad Classmate)\n\nAs we move through this mini-course, we will focus on challenging our programming skills with methods that require heavier statistical computation than typically used in our other courses. For this, we may need to use some more advanced types of objects in R, to use functions in more sophisticated ways and to build our own functions. This section will focus on more advanced data objects than vectors and data frames.\nWe will focus on two particularly helpful data structures:\n\nArrays\nLists\n\n\n1.4.1 Arrays\nVectors don’t have attributes, but we can add attributes that can change how the data is organized.\nAn array in R, is a vector for a \\(p\\)-dimensional index set. This dimension attribute allows the vector to be searched and subsetted very efficiently. Technically we have already seen a 2-dimensional vector; an R matrix. Because an array is a special kind of vector, all values stored inside an array must be the same atomic type.\nWhen doing computation things, if we are only guessing how R handles everything, we cannot leverage how R works to have more efficient code. Note that str() is structure, not string.\n\n# show that a matrix is a vector with dimension attributes\nsome_values &lt;- 1:20\nsome_values\n\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20\n\nstr(some_values)\n\n int [1:20] 1 2 3 4 5 6 7 8 9 10 ...\n\nattributes(some_values)\n\nNULL\n\nis.vector(some_values)\n\n[1] TRUE\n\nis.matrix(some_values)\n\n[1] FALSE\n\nis.array(some_values)\n\n[1] FALSE\n\n# add attributes, turning this into a matrix\ndim(some_values) &lt;- c(4,5)\nattributes(some_values)\n\n$dim\n[1] 4 5\n\nis.vector(some_values)\n\n[1] FALSE\n\nis.matrix(some_values)\n\n[1] TRUE\n\nis.array(some_values)\n\n[1] TRUE\n\n# we can define matrix with the matrix() function\nmy_matrix &lt;- matrix(some_values, nrow = 4, byrow = TRUE)\nis.vector(my_matrix)\n\n[1] FALSE\n\nis.matrix(my_matrix)\n\n[1] TRUE\n\nis.array(my_matrix)\n\n[1] TRUE\n\n\nDemonstrating Higher Dimensional Arrays:\n\nWhen unpacking a matrix (i.e. converting it back to a vector), R goes down the columns rather than across the rows.\n\n\n# unpack matrix\nmy_matrix\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    2    3    4    5\n[2,]    6    7    8    9   10\n[3,]   11   12   13   14   15\n[4,]   16   17   18   19   20\n\nas.vector(my_matrix) \n\n [1]  1  6 11 16  2  7 12 17  3  8 13 18  4  9 14 19  5 10 15 20\n\n\n\nAn array allows us to add an indexing structure (so we can subset these with square brackets), also allows sorting.\n\n\n# build an array here\nvec_to_array &lt;- 1:30\n\n # to convert the vector into an array: R went down the columns, across the rows, and then onto different layers\ndim(vec_to_array) &lt;- c(3,5,2)\nvec_to_array\n\n, , 1\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    4    7   10   13\n[2,]    2    5    8   11   14\n[3,]    3    6    9   12   15\n\n, , 2\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]   16   19   22   25   28\n[2,]   17   20   23   26   29\n[3,]   18   21   24   27   30\n\n# we can pull off a value by using bracket indexing\nvec_to_array[1,3,2]\n\n[1] 22\n\n# this can be very useful when the layers have characteristics (e.g. for simulations)\n\nWhy is this helpful? Suppose we are collecting the resulting values for simulating \\(n = 100\\) observations, from normals with means in \\(\\{-3,0,3\\}\\) and standard deviations in \\(\\{2,10\\}\\)\nUse an array to store the observation index in the first dimension, the means in the second dimension, and standard deviations in the third dimension. Thus we create a 100 by 3 by 2 array to store the data. This allows us to easily access the data we want using the indexing.\n\n# initialize simulation settings\nn &lt;- 100\nmeans &lt;- c(-3,0,3)\nsds &lt;- c(2,10)\n\n# initialize an empty array\nsim_data_array &lt;- array(rep(NA, n *length(means) * length(sds)),\n                        dim = c(n, length(means), length(sds)))\n\n# save the 100 simulated values into the array with corresponding mean and sd positions\nset.seed(12345)\nfor (j in 1:length(means)){\n  for (k in 1:length(sds)){\n    sim_data_array[ ,j, k] &lt;- rnorm(n, mean = means[j], sd = sds[k])\n  }\n}\n\n# explore values from second mean and second sd N(0,10)\nsummary(sim_data_array[,2,2])\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n-25.819  -3.191   3.466   2.153   6.968  22.679 \n\n\nWe can set up an array that is matches our simulation structure so that we can compactly store the results. Arrays like this are very efficient.\nKinda have to think about how assigning, and the values in the array in order to understand where the results go. Probably wouldn’t want to go more than 3 (maybe 4?) dimensions.\n\n1.4.2 Lists\nA list in R is an indexed set of other R objects that can be named. These objects do not all need to be the same type. Lists can help us to bundle together vectors, matrices, data frames, arrays, or even other lists.\n\n# build a list with several different object types\nmy_list &lt;- list(\n  num_vec = c(1,2,3,4,5),\n  letters = LETTERS[1:10],\n  hi = \"Hi Mom!\",\n  my_df = data.frame(x=1:5,y=rnorm(5)),\n  my_array = array(data=1:12,dim=c(3,2,2))\n)\nstr(my_list)\n\nList of 5\n $ num_vec : num [1:5] 1 2 3 4 5\n $ letters : chr [1:10] \"A\" \"B\" \"C\" \"D\" ...\n $ hi      : chr \"Hi Mom!\"\n $ my_df   :'data.frame':   5 obs. of  2 variables:\n  ..$ x: int [1:5] 1 2 3 4 5\n  ..$ y: num [1:5] -1.637 0.212 -0.465 -0.662 -0.133\n $ my_array: int [1:3, 1:2, 1:2] 1 2 3 4 5 6 7 8 9 10 ...\n\n# demonstrate indexing\nmy_list[[3]]\n\n[1] \"Hi Mom!\"\n\nmy_list[[1]] * 2\n\n[1]  2  4  6  8 10\n\nmy_list[[4]][ ,2]\n\n[1] -1.6366291  0.2115626 -0.4648317 -0.6623572 -0.1329536\n\n# demonstrate nested naming\nmy_list$hi\n\n[1] \"Hi Mom!\"\n\nmy_list$my_df$y\n\n[1] -1.6366291  0.2115626 -0.4648317 -0.6623572 -0.1329536",
    "crumbs": [
      "Course Notes",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Beyond Dataframes</span>"
    ]
  },
  {
    "objectID": "using-and-building-functions.html#overview",
    "href": "using-and-building-functions.html#overview",
    "title": "2  Using and Building Functions",
    "section": "\n2.1 Overview",
    "text": "2.1 Overview\nThis section will discuss R functions. Functions are the engines that define how to DO things with your data objects in R. If data objects are the “nouns”, then functions are the “verbs” of the R language.\nWhy build functions?\n\nBecause it is fun (for us nerdy people).\nBecause we find ourselves doing the same task multiple times throughout our code, and realize that each iteration is mostly the same process using slightly different values or variables.\nBecause we want to avoid copy/paste related errors.\nBecause we want to make our code more readable.\n\nThis will discuss the basic structure and components of a function, how a function is created, passing parameters implicitly versus explicitly in a function call, name masking in nested environments, and infix operators.\nBelow are links to supplementary resources about building functions in R:\n\nAdvanced R Functions Chapter\nAdditional Functions Reading from R for Data Science E-book",
    "crumbs": [
      "Course Notes",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Using and Building Functions</span>"
    ]
  },
  {
    "objectID": "using-and-building-functions.html#creating-functions",
    "href": "using-and-building-functions.html#creating-functions",
    "title": "2  Using and Building Functions",
    "section": "\n2.3 Creating Functions",
    "text": "2.3 Creating Functions\nTo create a function you must define the formals and body in using the function() function, and assign the definition to a name.\n\nBelow we are giving a function as a value to the function name.\nFunctions are first class objects (they store expressions, rather than data values).\nIf there is a set of things we want to do, we can wrap a bunch of code into an expression by wrapping in curly brackets, then R thinks about it as one thing.\n\n\n# writing functions\nfunction_name &lt;- function(formal_arguments_go_here) {\n  # code body expression goes here\n}\n\nformals(function_name)\n\n$formal_arguments_go_here\n\nbody(function_name)\n\n{\n}\n\nenvironment(function_name)\n\n&lt;environment: R_GlobalEnv&gt;\n\n\nAlso note, function() is a very weird function, since the body argument goes outside the parentheses! Technically even the example above is a real function (albeit a boring one).\nBetter example of simple function for adding up two numbers.\n\nGive functions a name that indicate what it does (intuitive names help a great deal with readable code).\n\nStyle guide: Can use the assignment arrow &lt;- for anytime something will be saved to the global environment (data values and functions), but within a function we can use = because it is only found locally and is temporary.\n\n\n&lt;&lt;- Assigns values from a local environment (like a function call) and saves it in the global environment (this is a really bad idea because it could overwrite something that you already have in the global environment)\n\n\nReturning values: Functions implicitly return the last thing computed. So it is often a good idea to be explicit about what to return.\n\n\n# write function add two numbers\nmy_sum &lt;- function(x, y){\n  val = x + y\n  return(val)\n}\nmy_sum(1,2)\n\n[1] 3\n\n# bad idea\nmy_sum &lt;- function(x, y){\n  val &lt;&lt;- x + y\n  return(val)\n}\n# val isn't in the global environment\nmy_sum(1, 2)\n\n[1] 3\n\n\nMore complex functions: In a legitimate function, to have our function behave differently, we can use some if and else statements that are usually triggered by a yes / no or true / false.\n\n# label: defining-functions-ifs\n\n# now trying to do something cool (and / or breaking it)\n# -&gt; on rare occasions, add some random error to the sum\nmy_sum &lt;- function(x, y, mischief = TRUE){\n  if(mischief == FALSE){\n    val = x + y\n  } else {\n    val = x + y + sample(c(-1,0,1), size = 1, prob = c(.02,.96,.02))\n  }\n  return(val)\n}\n\n# run the function 100 times using specified values for the arguments\n# -&gt; not using the X in our function call\nsapply(X = 1:100, my_sum, x = 1, y = 2)\n\n  [1] 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3\n [38] 3 3 3 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4 3 3 3 3 3 3 3 3 3 3 3 3\n [75] 3 3 3 3 3 3 3 3 3 3 3 3 3 3 2 3 3 3 4 3 3 3 3 3 3 3\n\n# equivalent to\nfor (i in 1:100) {\n  print(my_sum(1, 2))\n}\n\n[1] 3\n[1] 3\n[1] 3\n[1] 3\n[1] 3\n[1] 3\n[1] 3\n[1] 3\n[1] 3\n[1] 3\n[1] 3\n[1] 3\n[1] 3\n[1] 3\n[1] 3\n[1] 3\n[1] 3\n[1] 3\n[1] 3\n[1] 3\n[1] 3\n[1] 3\n[1] 3\n[1] 2\n[1] 3\n[1] 3\n[1] 2\n[1] 3\n[1] 3\n[1] 3\n[1] 3\n[1] 3\n[1] 3\n[1] 3\n[1] 2\n[1] 3\n[1] 3\n[1] 3\n[1] 3\n[1] 3\n[1] 3\n[1] 3\n[1] 3\n[1] 3\n[1] 3\n[1] 3\n[1] 3\n[1] 3\n[1] 2\n[1] 3\n[1] 4\n[1] 3\n[1] 3\n[1] 3\n[1] 3\n[1] 3\n[1] 3\n[1] 3\n[1] 3\n[1] 3\n[1] 3\n[1] 3\n[1] 3\n[1] 3\n[1] 3\n[1] 3\n[1] 3\n[1] 3\n[1] 3\n[1] 3\n[1] 3\n[1] 3\n[1] 3\n[1] 3\n[1] 3\n[1] 3\n[1] 3\n[1] 3\n[1] 3\n[1] 2\n[1] 3\n[1] 3\n[1] 4\n[1] 3\n[1] 3\n[1] 2\n[1] 3\n[1] 3\n[1] 3\n[1] 3\n[1] 3\n[1] 4\n[1] 3\n[1] 3\n[1] 3\n[1] 3\n[1] 2\n[1] 3\n[1] 3\n[1] 3\n\n\nCan return something more complex than just a data value by returning lists. Functions that output lists are kinda the next step of complex computing ideas.\n\n# label: defining-functions-return-list\n\n# modify function to return a list with multiple objects in it\nmy_sum &lt;- function(x, y, mischief = TRUE){\n  if(mischief == FALSE){\n    val = x + y\n  } else {\n    val = x + y + sample(c(-1,0,1), size = 1, prob = c(.02,.96,.02))\n  }\n  return(list(value = val,\n              mischief = mischief))\n}\n\nmy_sum(1, 2)\n\n$value\n[1] 3\n\n$mischief\n[1] TRUE\n\n\nsapply() is a function that calls other functions in an iterative way (really efficient for loop).\n\n2.3.1 Calling a Function\nTo call a function, you simply use its name and define any required formal arguments. Typically this is done within a set of parentheses directly following the function name. Only a few special cases break from that pattern.\nWhat is more important to focus on is if and how we define the arguments. We may choose to define nothing in the arguments and the function might still work.\n\n# write function that has no arguments to simply return this hardcoded value\nno_arg &lt;- function(){\n  x = 10\n  return(x)\n}\nno_arg()\n\n[1] 10\n\n# -&gt; so it will generate an error if we tried to give it an argument that isn't defined in the function\nno_arg(x = 20)\n\nError in no_arg(x = 20): unused argument (x = 20)\n\n\nTypically these are made more flexible using dots .... All this does is put the values into the local namespace and continues running the function. These are optional arguments.\n\n# define function wtih ... formal\nno_arg2 &lt;- function(...){\n  x = 10\n  return(x)\n}\n\n# functions works with no arguments\nno_arg2() \n\n[1] 10\n\n# and now with arguments\n# -&gt; it initializes the value of x, but then  overwrites the value of x internally\nno_arg2(x = 20)\n\n[1] 10\n\n\nFor “optional” arguments (arguments that sometimes matters and sometimes don’t matter), we should define them as formal parameters with some default values. This way we can override them if we wanted to.\n\n# add default value to argument\n# -&gt; now it behaves typically how we want, but can change them if we want\nno_arg3 &lt;- function(x = 10){\n  return(x)\n}\n\n# this is the behavior we typically will want\nno_arg3()\n\n[1] 10\n\nno_arg3(x = 20)\n\n[1] 20\n\n\nThe more important characteristics of function calls are related to how we define our arguments: implicitly and explicitly. If we rely on the default ordering of the arguements, then we are calling the arguments implicitly. If we refer to the argument by it’s name while defining the values, then we are calling the argument explicitly. Often we use a mix of these methods, but it is important to be aware of how and why we choose to define our arguments.\nA function runs through all of the named arguments, then goes in order for the unnamed arguments.\n\n# all of the following are equivalent\nmean(x = 1:5, na.rm = TRUE)\n\n[1] 3\n\nmean(1:5, na.rm = TRUE)\n\n[1] 3\n\nmean(na.rm = TRUE, x = 1:5)\n\n[1] 3\n\n# the following is NOT equivalent\n# -&gt; it is expecting a numeric first\nmean(TRUE, 1:5)\n\nError in mean.default(TRUE, 1:5): 'trim' must be numeric of length one\n\n\nPossible convention: Implicitly give the function data values first, then use explicit calling for the options (this will still be readable because the function name will indicate what it’s going to do with the data values).\n\n2.3.2 Automating procedures\nThe following example demonstrates code that would be better served by constructing a function to accomplish the task.\n\n# take the following olive oil data and standardize the columns\nlibrary(pdfCluster) # for the data\ndata(oliveoil) # ?oliveoil\n\n# start with a dataframe where create the z-scores for palmitic acid, then add the rest \noo_standardized &lt;- data.frame(\n  palmitic = (oliveoil[,\"palmitic\"]-mean(oliveoil[,\"palmitic\"]))/sd(oliveoil[,\"palmitic\"])\n)\nhead(oo_standardized)\n\n    palmitic\n1 -0.9297061\n2 -0.8525970\n3 -1.9024672\n4 -1.5762364\n5 -1.0720614\n6 -1.9024672\n\n# do this better with a function, rather than copy and paste and change column names\noo_standardized2 &lt;- data.frame(\n  oleic = (oliveoil[,\"oleic\"]-mean(oliveoil[,\"oleic\"]))/sd(oliveoil[,\"oleic\"])\n)\nhead(oo_standardized2)\n\n      oleic\n1 1.2598296\n2 0.9789102\n3 1.9744494\n4 1.5777122\n5 1.1316909\n6 1.5087145\n\n# write function to take a variable name and return the standardized column\noo_stand &lt;- function(varname) {\n  (oliveoil[,varname]-mean(oliveoil[,varname]))/sd(oliveoil[,varname])\n}\nhead(oo_stand(\"palmitic\"))\n\n[1] -0.9297061 -0.8525970 -1.9024672 -1.5762364 -1.0720614 -1.9024672\n\n# loop over all column names with sapply()\noo_standardized3 &lt;- sapply(X = names(oliveoil)[3:10], FUN = oo_stand)",
    "crumbs": [
      "Course Notes",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Using and Building Functions</span>"
    ]
  },
  {
    "objectID": "using-and-building-functions.html#r-function-basics---components",
    "href": "using-and-building-functions.html#r-function-basics---components",
    "title": "2  Using and Building Functions",
    "section": "\n2.2 R Function Basics - Components",
    "text": "2.2 R Function Basics - Components\n\n``To understand computations in R, two slogans are helpful: Everything that exists is an object. Everything that happens is a function call.’’ — John Chambers\n\nFormals: The defined parameters of a function. Think of these as the set of data objects and options that can be defined by the programmer when a function is used.\nFor these exercises we will consider the following functions:\n\n\nmean() from base R\n\nggplot() from the ggplot2 package\n\n%&gt;% piping symbol from the dplyr package\n\n\nlibrary(tidyverse)\n\n# a function without parentheses prints what it is\n# -&gt; with the parenthesis, it tells R to run it\nmean\n\nfunction (x, ...) \nUseMethod(\"mean\")\n&lt;bytecode: 0x7fda9fd08578&gt;\n&lt;environment: namespace:base&gt;\n\nggplot\n\nfunction (data = NULL, mapping = aes(), ..., environment = parent.frame()) \n{\n    UseMethod(\"ggplot\")\n}\n&lt;bytecode: 0x7fda6da13ac0&gt;\n&lt;environment: namespace:ggplot2&gt;\n\n\nPipe\n\nThis is actually quite a complex function (yes, a function) (things like this are called infix operator). Infix operators go in between arguments.\nCan surround an infix operator with tick marks to see what this function is actually doing.\n\n\n# infix operator: pipe\n`%&gt;%`\n\nfunction (lhs, rhs) \n{\n    lhs &lt;- substitute(lhs)\n    rhs &lt;- substitute(rhs)\n    kind &lt;- 1L\n    env &lt;- parent.frame()\n    lazy &lt;- TRUE\n    .External2(magrittr_pipe)\n}\n&lt;bytecode: 0x7fda8d9cc3e0&gt;\n&lt;environment: namespace:magrittr&gt;\n\n\n\nAnother example is +. This is a primitive function, which just means that R doesn’t evaluate it. It sends it down and is evaluated in C (because it is more efficient).\n\n\n# infix operator as function\n`+`(2, 3)\n\n[1] 5\n\n\n\n2.2.1 Formals\nWhat are the formals for these functions?\n\n\n?formals(): Formals are things that we define to change the behavior of the outcome.\n\n\n# view formals\nformals(`%&gt;%`)\n\n$lhs\n\n\n$rhs\n\nformals(mean)\n\n$x\n\n\n$...\n\n\n\n... are a special (very flexible, catch all) type of formal argument that we can put non-necessary arguments.\nFor example, with mean mean(x, na.rm = TRUE), this saves the value TRUE to na.rm argument and saves that value as the function is run.\n\n2.2.2 Body\nThe lines of code that will be run when the function is called. The body uses the formals and usually returns a result of some kind.\n\n# body()\nbody(`+`)\n\nNULL\n\n# -&gt; returns null because the function isn't run in R\n\nbody(ggplot)\n\n{\n    UseMethod(\"ggplot\")\n}\n\n\n\nNote that the code in the body is never commented because R strips away the comments when running to make its more compact. When we write functions, we add comments so the humans know what it does, but when it is stored they are removed to take up less space.\n\n2.2.3 Environment\nThe environment is the group of named objects which functions have access to. In other words, it is where the function will retrieve named objects used to execute the code from the body.\n\nThe global environment is everything that we have loaded in, created ourselves or in base R.\nls() tells you what you have created / assigned in the global environment (to get, set, test for and create environments, use environment()).\n\n\n# ?environment()\nls()\n\n[1] \"has_annotations\"\n\ny &lt;- 1:5\nls()\n\n[1] \"has_annotations\" \"y\"              \n\n\n\nWhen calling functions, they have access to the names of objects in the namespace. It can map the name to where the object is stored. So it retrieves values through the names, so names are very powerful and why we can do computation work that is readable.\n\n\n# y is now in the namespace, so we have access to it\n# -&gt; the name gets mapped to its value\ny*2\n\n[1]  2  4  6  8 10\n\nhead(iris)\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n3          4.7         3.2          1.3         0.2  setosa\n4          4.6         3.1          1.5         0.2  setosa\n5          5.0         3.6          1.4         0.2  setosa\n6          5.4         3.9          1.7         0.4  setosa\n\n# -&gt; we were able to find this because head and iris are a namespace in the global environment\n\n\nWhen we load a library, we are loading a namespace that has access to all the function names and dataset names in the library (package). Everything is a named object (objects, functions, etc.) and they are saved somewhere. The environment is where R finds the object.\n\nLocal namespaces\n\nWhen a function is called, a local namespace is created within the global environment (like a subspace of the global environment).\nWhen code is run in this local environment, R has access to all objects contained in the global environment.\nThe primary difference is that when the local namespace is created, the formal argument names and their defined values are written into the local namespace. If these objects already exist in the global environment, they are overwritten locally while the function code is running. This is referred to as name masking.\nAfter the function code has completed running, the local environment is deleted. Thus, the local environment of a function is both nested in the global environment and is temporary.\n\n\n# when we call the mean function, x is defined locally but not globally\nmean(x = y)\n\n[1] 3",
    "crumbs": [
      "Course Notes",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Using and Building Functions</span>"
    ]
  }
]