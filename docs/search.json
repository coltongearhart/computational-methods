[
  {
    "objectID": "course-notes.html",
    "href": "course-notes.html",
    "title": "Course Notes",
    "section": "",
    "text": "This section contains the notes from the course.",
    "crumbs": [
      "Course Notes"
    ]
  },
  {
    "objectID": "assignments.html",
    "href": "assignments.html",
    "title": "Assignments",
    "section": "",
    "text": "This section contains the assignments from the course.",
    "crumbs": [
      "Assignments"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Computational Methods in R",
    "section": "",
    "text": "Overview\n&lt; insert table with links to each chapters and brief descriptions from the schedule &gt;\n\n\n\n\n\n\nQuarto blog publish details\n\n\n\nThis book was created using Quarto and published with Github Pages.\n\n\n\n\n\n\n\n\nGithub repository for code\n\n\n\nYou can find the code to reproduce this project at coltongearhart/climate-dataviz.",
    "crumbs": [
      "Overview"
    ]
  },
  {
    "objectID": "beyond-dataframes.html#overview",
    "href": "beyond-dataframes.html#overview",
    "title": "1  Beyond Dataframes",
    "section": "\n1.1 Overview",
    "text": "1.1 Overview\nIn this mini courese we will be exploring the use of computing and non-parametric method in statistical practice. This will look like a set of general programming and computing topics and methods. This will require that we use a statistical programming language in sophisticated ways, and the module will specifically explore techniques for advanced programming in R.\nReadings come from the Advanced R textbook by Hadley Wickham.\n\n``To understand computations in R, two slogans are helpful: Everything that exists is an object. Everything that happens is a function call.’’ — John Chambers\n\nYou already know the basics from your previous coursework. Here we will briefly discuss the following:\n\n\nDocumenting Code\n\nNaming objects, functions, variables\nDescriptive comments\nStructural organization\n\n\n\nObjects\n\nVectors, atomic types, attributes\nDataframes\nMatrices\n\n\n\nFunctions\n\nUsing existing functions\nFinding and reading help documentation",
    "crumbs": [
      "Course Notes",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Beyond Dataframes</span>"
    ]
  },
  {
    "objectID": "beyond-dataframes.html#coding-in-r---documenting-with-quarto",
    "href": "beyond-dataframes.html#coding-in-r---documenting-with-quarto",
    "title": "1  Beyond Dataframes",
    "section": "\n1.2 Coding in R - Documenting with Quarto",
    "text": "1.2 Coding in R - Documenting with Quarto\nIn this mini-course, we will be coding and programming using the R language. We will be leveraging the benefits of the open source structure of R by using some of the excellent software packages developed by members of the R community. We will also be exploring the efficient data structures and functions available in Base R. We will be interacting with the R language using the R Studio Interactive Development Environment (IDE).\nWe will be using Quarto to document our work because it is capable of integrating the process of writing in both programming and natural languages. It is great to be able to transition back and forth between paragraphs expressing what we are trying to accomplish statistically to the computational evidence to support our results. Each course notes will be put together as a Quarto document.\nSupplementary Resources for R Markdown:\n\nQuarto Website\nQuarto computations in R\nR Markdown Reference Guide",
    "crumbs": [
      "Course Notes",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Beyond Dataframes</span>"
    ]
  },
  {
    "objectID": "beyond-dataframes.html#r-basics",
    "href": "beyond-dataframes.html#r-basics",
    "title": "1  Beyond Dataframes",
    "section": "\n1.3 R Basics",
    "text": "1.3 R Basics\nData structures\n\nVectors are the atomic vectors of type: numeric, character, logical\nEssentially every data structure we use is one of these vectors, but with additional attributes or several vectors added together.\nA fundamental aspect of good computing is understanding how R saves the information.\nWe can also concatenate vectors of different types. However, atomic vectors cannot contain more than one type of data, so it coerces values into a easier way.\nWe are starting to think about these vector / dataframes. A vector is a one dimensional, matrix is two dimensions, arrays are three dimensional.\n\nExample below for demonstrating different aspects of R such as packages, objects, functions, etc. and for improving code readability.\n\nThe assignment arrow is pronounced “gets”, so the name gets the thing on the right.\n\n\n# poor formatting makes cord hard to read \nlibrary(tidyverse)\nrealestate&lt;-read.csv(\"Files/Data/realestate.csv\")\nprice_means&lt;-rep(NA   ,1000);price_medians&lt;-rep(NA   ,1000)\nfor(b in 1:1000){`bootstrap sample`&lt;-sample_n(realestate  ,nrow(realestate)  ,T)\nprice_means[b]&lt;-mean(`bootstrap sample`$price   )\nprice_medians[b]&lt;-median(`bootstrap sample`$price    )}\nquantile(price_means   ,c(0.025,0.975));quantile(price_medians   ,c(0.025,0.975));t.test(realestate$price)\n\nReformat R scripts\n\n\nUse the following shortcuts in RStudio to reformat your code in the qmd file:\n\nCmd + I: Fixes line indentations.\nCmd + Shift + A: Does a complete reformat of the selected part of a code.\n\n\n\n\n# use keyboard shortcut for quick fixes\nlibrary(tidyverse)\nrealestate &lt;- read.csv(\"Files/Data/realestate.csv\"); price_means &lt;- rep(NA   , 1000)\nprice_medians &lt;- rep(NA   , 1000)\nfor (b in 1:1000) {\n  `bootstrap sample` &lt;- sample_n(realestate  , nrow(realestate)  , T)\n  price_means[b] &lt;- mean(`bootstrap sample`$price)\n  price_medians[b] &lt;- median(`bootstrap sample`$price)\n}\nquantile(price_means   , c(0.025, 0.975))\nquantile(price_medians   , c(0.025, 0.975))\nt.test(realestate$price)\n\nUse automated code parsing and then copy result into qmd file.\n\nUse knitr chunk options with formatR installed: tidy: formatR. This parses the code with tidy_source() behind the scenes.\nCan specify additional options with #| tidy-opts: #|   -. View available ones in the help documentation ?tidy_source or this r markdown cookbook section.\n\n\n# automated code parsing -&gt; this has the same source as the first ugly code,\n# but echos nicely\nlibrary(tidyverse)\nrealestate &lt;- read.csv(\"Files/Data/realestate.csv\")\nprice_means &lt;- rep(NA, 1000)\nprice_medians &lt;- rep(NA, 1000)\nfor (b in 1:1000) {\n    `bootstrap sample` &lt;- sample_n(realestate, nrow(realestate), T)\n    price_means[b] &lt;- mean(`bootstrap sample`$price)\n    price_medians[b] &lt;- median(`bootstrap sample`$price)\n}\nquantile(price_means, c(0.025, 0.975))\nquantile(price_medians, c(0.025, 0.975))\nt.test(realestate$price)\n\nRebuilding code for readability (with comments)\n\n# now we can add comments and space out the code for better readability\nlibrary(tidyverse)\nrealestate &lt;- read.csv(\"Files/Data/realestate.csv\")\n\n# initializing the storage space for the bootstrap means and medians\nprice_means &lt;- rep(NA, 1000)\nprice_medians &lt;- rep(NA, 1000)\n\n# loop over 1000 repeated bootstrap samples, saving the means and medians\nfor (b in 1:1000) {\n  bootstrap_sample &lt;- sample_n(realestate, nrow(realestate), T)\n  price_means[b] &lt;- mean(bootstrap_sample$price)\n  price_medians[b] &lt;- median(bootstrap_sample$price)\n}\n\n# calculate the quantiles of the collected means and medians\nquantile(price_means, c(0.025, 0.975))\n\n    2.5%    97.5% \n266524.1 289583.4 \n\nquantile(price_medians, c(0.025, 0.975))\n\n  2.5%  97.5% \n219900 239950 \n\n# do these intervals match will with confidence intervals using central limit theorem?\n# -&gt; compare interval to t-interval\nt.test(realestate$price)\n\n\n    One Sample t-test\n\ndata:  realestate$price\nt = 46.034, df = 521, p-value &lt; 2.2e-16\nalternative hypothesis: true mean is not equal to 0\n95 percent confidence interval:\n 266034.8 289753.5\nsample estimates:\nmean of x \n 277894.1",
    "crumbs": [
      "Course Notes",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Beyond Dataframes</span>"
    ]
  },
  {
    "objectID": "beyond-dataframes.html#advanced-programming",
    "href": "beyond-dataframes.html#advanced-programming",
    "title": "1  Beyond Dataframes",
    "section": "\n1.4 Advanced Programming",
    "text": "1.4 Advanced Programming\n\n``We are adventurers! We do not play on the playgrounds. We roam in the jungles!’’ — Jie Li (Dr. Maurer’s Grad Classmate)\n\nAs we move through this mini-course, we will focus on challenging our programming skills with methods that require heavier statistical computation than typically used in our other courses. For this, we may need to use some more advanced types of objects in R, to use functions in more sophisticated ways and to build our own functions. This section will focus on more advanced data objects than vectors and data frames.\nWe will focus on two particularly helpful data structures:\n\nArrays\nLists\n\n\n1.4.1 Arrays\nVectors don’t have attributes, but we can add attributes that can change how the data is organized.\nAn array in R, is a vector for a \\(p\\)-dimensional index set. This dimension attribute allows the vector to be searched and subsetted very efficiently. Technically we have already seen a 2-dimensional vector; an R matrix. Because an array is a special kind of vector, all values stored inside an array must be the same atomic type.\nWhen doing computation things, if we are only guessing how R handles everything, we cannot leverage how R works to have more efficient code. Note that str() is structure, not string.\n\n# show that a matrix is a vector with dimension attributes\nsome_values &lt;- 1:20\nsome_values\n\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20\n\nstr(some_values)\n\n int [1:20] 1 2 3 4 5 6 7 8 9 10 ...\n\nattributes(some_values)\n\nNULL\n\nis.vector(some_values)\n\n[1] TRUE\n\nis.matrix(some_values)\n\n[1] FALSE\n\nis.array(some_values)\n\n[1] FALSE\n\n# add attributes, turning this into a matrix\ndim(some_values) &lt;- c(4,5)\nattributes(some_values)\n\n$dim\n[1] 4 5\n\nis.vector(some_values)\n\n[1] FALSE\n\nis.matrix(some_values)\n\n[1] TRUE\n\nis.array(some_values)\n\n[1] TRUE\n\n# we can define matrix with the matrix() function\nmy_matrix &lt;- matrix(some_values, nrow = 4, byrow = TRUE)\nis.vector(my_matrix)\n\n[1] FALSE\n\nis.matrix(my_matrix)\n\n[1] TRUE\n\nis.array(my_matrix)\n\n[1] TRUE\n\n\nDemonstrating Higher Dimensional Arrays:\n\nWhen unpacking a matrix (i.e. converting it back to a vector), R goes down the columns rather than across the rows.\n\n\n# unpack matrix\nmy_matrix\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    2    3    4    5\n[2,]    6    7    8    9   10\n[3,]   11   12   13   14   15\n[4,]   16   17   18   19   20\n\nas.vector(my_matrix) \n\n [1]  1  6 11 16  2  7 12 17  3  8 13 18  4  9 14 19  5 10 15 20\n\n\n\nAn array allows us to add an indexing structure (so we can subset these with square brackets), also allows sorting.\n\n\n# build an array here\nvec_to_array &lt;- 1:30\n\n # to convert the vector into an array: R went down the columns, across the rows, and then onto different layers\ndim(vec_to_array) &lt;- c(3,5,2)\nvec_to_array\n\n, , 1\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    4    7   10   13\n[2,]    2    5    8   11   14\n[3,]    3    6    9   12   15\n\n, , 2\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]   16   19   22   25   28\n[2,]   17   20   23   26   29\n[3,]   18   21   24   27   30\n\n# we can pull off a value by using bracket indexing\nvec_to_array[1,3,2]\n\n[1] 22\n\n# this can be very useful when the layers have characteristics (e.g. for simulations)\n\nWhy is this helpful? Suppose we are collecting the resulting values for simulating \\(n = 100\\) observations, from normals with means in \\(\\{-3,0,3\\}\\) and standard deviations in \\(\\{2,10\\}\\)\nUse an array to store the observation index in the first dimension, the means in the second dimension, and standard deviations in the third dimension. Thus we create a 100 by 3 by 2 array to store the data. This allows us to easily access the data we want using the indexing.\n\n# initialize simulation settings\nn &lt;- 100\nmeans &lt;- c(-3,0,3)\nsds &lt;- c(2,10)\n\n# initialize an empty array\nsim_data_array &lt;- array(rep(NA, n *length(means) * length(sds)),\n                        dim = c(n, length(means), length(sds)))\n\n# save the 100 simulated values into the array with corresponding mean and sd positions\nset.seed(12345)\nfor (j in 1:length(means)){\n  for (k in 1:length(sds)){\n    sim_data_array[ ,j, k] &lt;- rnorm(n, mean = means[j], sd = sds[k])\n  }\n}\n\n# explore values from second mean and second sd N(0,10)\nsummary(sim_data_array[,2,2])\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n-25.819  -3.191   3.466   2.153   6.968  22.679 \n\n\nWe can set up an array that is matches our simulation structure so that we can compactly store the results. Arrays like this are very efficient.\nKinda have to think about how assigning, and the values in the array in order to understand where the results go. Probably wouldn’t want to go more than 3 (maybe 4?) dimensions.\n\n1.4.2 Lists\nA list in R is an indexed set of other R objects that can be named. These objects do not all need to be the same type. Lists can help us to bundle together vectors, matrices, data frames, arrays, or even other lists.\n\n# build a list with several different object types\nmy_list &lt;- list(\n  num_vec = c(1,2,3,4,5),\n  letters = LETTERS[1:10],\n  hi = \"Hi Mom!\",\n  my_df = data.frame(x=1:5,y=rnorm(5)),\n  my_array = array(data=1:12,dim=c(3,2,2))\n)\nstr(my_list)\n\nList of 5\n $ num_vec : num [1:5] 1 2 3 4 5\n $ letters : chr [1:10] \"A\" \"B\" \"C\" \"D\" ...\n $ hi      : chr \"Hi Mom!\"\n $ my_df   :'data.frame':   5 obs. of  2 variables:\n  ..$ x: int [1:5] 1 2 3 4 5\n  ..$ y: num [1:5] -1.637 0.212 -0.465 -0.662 -0.133\n $ my_array: int [1:3, 1:2, 1:2] 1 2 3 4 5 6 7 8 9 10 ...\n\n# demonstrate indexing\nmy_list[[3]]\n\n[1] \"Hi Mom!\"\n\nmy_list[[1]] * 2\n\n[1]  2  4  6  8 10\n\nmy_list[[4]][ ,2]\n\n[1] -1.6366291  0.2115626 -0.4648317 -0.6623572 -0.1329536\n\n# demonstrate nested naming\nmy_list$hi\n\n[1] \"Hi Mom!\"\n\nmy_list$my_df$y\n\n[1] -1.6366291  0.2115626 -0.4648317 -0.6623572 -0.1329536",
    "crumbs": [
      "Course Notes",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Beyond Dataframes</span>"
    ]
  }
]